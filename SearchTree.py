# 탐색트리
# • 저장된 데이터에 대해 탐색, 삽입, 삭제, 갱신 등의 연산을 수행할 수
# 있는 자료구조
# • 1차원 리스트나 연결리스트는 각 연산을 수행하는데 O(N) 시간이 소
# 요
# • 스택이나 큐는 특정 작업에 적합한 자료구조.
# • 리스트 자료구조의 수행시간을 향상시키기 위한 트리 형태의 다양한
# 사전 자료구조들을 소개
# • 이진탐색트리, AVL트리, 2-3트리, 레드블랙트리, B-트리
#
# 이진탐색
# • 정렬된 데이터의 중간에 위치한 항목을 기준으로 데이터를 두 부분
# 으로 나누어 가며 특정 항목을 찾는 탐색방법
#
# 수행시간
# • T(N) = 입력 크기 N인 정렬된 리스트에서 이진탐색을 하는데 수행
# 되는 키 비교 횟수
# • T(N)은 1번의 비교 후에 리스트의 1/2, 즉, 앞부분이나 뒷부분을 재
# 귀호출하므로 O(logN)
#
# 이진탐색트리 Binary Search Tree
# • 이진탐색(Binary Search)의 개념을 트리 형태의 구조에 접목한 자
# 료구조
# • 이진탐색(Binary Search)의 개념을 트리 형태의 구조에 접목한 자
# 료구조
# • 이진탐색트리는 이진트리로서 각 노드가 다음과 같은 조건을 만족
# 한다.
# • 각 노드 n의 키가 n의 왼쪽 서브트리에 있는 키들보다 (같거나)
# 크고, n의 오른쪽 서브트리에 있는 키들보다 작다. [이진탐색트
# 리 조건]
#
# 탐색연산: get(key)
# • 탐색하고자 하는 키가 k라면, 루트의 키와 k를 비교하는 것으로 탐
# 색을 시작
# • k가 루트의 키가 k 보다 작으면, 루트의 왼쪽 서브트리에서 k를 찾
# 고, 크면 루트의 오른쪽 서브트리에서 k를 찾으며, 같으면 탐색 성공
# • 왼쪽이나 오른쪽 서브트리에서 k를 탐색은 루트에서의 탐색과 동일
#
# 삽입연산: put(key, value)
# • 삽입은 탐색 연산과 거의 동일
# • 탐색 중 None을 만나면 새 노드를 생성하여 부모노드와 연결
# • 단, 이미 트리에 존재하는 키를 삽입한 경우, value만 갱신
#
# 최소값 찾기
# • 최솟값은 루트노드로부터 왼쪽 자식을 따라 내려가며, None을 만
# 났을 때 None의 부모가 가진 value
#
# 최소값 삭제
# • 최솟값을 가진 노드를 삭제하는 것은 최솟값을 가진 노드 n을 찾아
# 낸 뒤, n의 부모 p와 n의 오른쪽 자식 c를 연결
# • 이 때 c 가 None이더라도 자식으로 연결
#
# 삭제연산: delete(key)
# • 우선 삭제하고자 하는 노드를 찾은 후 이진탐색트리 조건을 만족하
# 도록 삭제된 노드의 부모와 자식(들)을 연결해 주어야 함
# • 삭제되는 노드가 자식이 없는 경우(case 0), 자식이 하나인 경우
# (case 1), 자식이 둘인 경우(case 2)로 나누어 delete 연산을 수행
# • Case 0: 삭제해야 할 노드 n의 부모가 n을 가리키던 레퍼런스를
# None으로 만든다.
# • Case 1: n가 한쪽 자식인 c만 가지고 있다면, n의 부모와 n의 자
# 식 c를 직접 연결
# • Case 2: n의 부모는 하나인데 n의 자식이 둘이므로 n의 자리에
# 중위순회하면서 n을 방문하기 직전 노드(Inorder Predecessor,
# 중위 선행자) 또는 직후에 방문되는 노드(Inorder Successor, 중
# 위 후속자)로 대체
#
# 수행시간
# • 이진탐색트리에서 탐색, 삽입, 삭제 연산은 공통적으로 루트에서 탐
# 색을 시작하여 최악의 경우에 이파리까지 내려가고, 삽입과 삭제 연
# 산은 다시 루트까지 거슬러 올라가야 함
# • 트리를 한 층 내려갈 때는 재귀호출이 발생하고, 한 층을 올라갈 때
# 는 재 연결이 수행되는데, 이들 각각은 O(1) 시간 소요
# • 연산들의 수행시간은 각각 트리의 높이(h)에 비례, O(h)
# • N개의 노드가 있는 이진탐색트리의 높이가 가장 낮은 경우는 완전
# 이진트리 형태일 때이고, 가장 높은 경우는 편향이진트리
# • 따라서 이진트리의 높이 h는 아래와 같다
# [log (N+1)] = log N ≤ h ≤ N
# • Empty 이진탐색트리에 랜덤하게 선택된 N개의 키를 삽입한다고
# 가정했을 때, 트리의 높이는 약 1.39 log N
#
# AVL트리
# • AVL 트리는 트리가 한쪽으로 치우쳐 자라나는 현상을 방지하여 트
# 리 높이의 균형(Balance)을 유지하는 이진탐색트리
# • 균형(Balanced) 이진트리를 만들면 N개의 노드를 가진 트리의 높
# 이가 O(logN)이 되어 탐색, 삽입, 삭제 연산의 수행시간이 O(logN)
# 으로 보장
# • [핵심 아이디어] AVL트리는 삽입이나 삭제로 인해 균형이 깨지면
# 회전 연산을 통해 트리의 균형을 유지한다
# • AVL트리는 임의의 노드 x에 대해 x의 왼쪽 서브트리의 높이와 오
# 른쪽 서브트리의 높이 차이가 1을 넘지 않는 이진탐색트리이다
# • [정리] N개의 노드를 가진 AVL 트리의 높이는 O(logN)이다.
# • [증명] A(h) = 높이가 h인 AVL 트리를 구성하는 최소의 노드 수
# A(1) = 1, A(2) = 2, A(3) = 4이다
# •이를 A(h)에 대한 식으로 표현하면
# A(h) = A(h-1) + A(h-2) + 1, 단, A(0)=0, A(1)=1, A(2)=2
# • A(h)와 피보나치 수 F(h)와의 관계
# A(h) = F(h+2) – 1
# • A(h) = 높이가 h인 AVL트리에 있는 최소 노드 수이므로, 노드 수가
# N인 임의의 AVL트리의 최대 높이를 A(h) ≤ N의 관계에서 다음과
# 같이 계산할 수 있다 O(logN)
#
# 4가지 회전의 공통정
# • 회전 후의 트리들이 모두 동일
# • 각 회전 연산의 수행시간이 O(1)
#
#  AVL 트리의 삽입연산
# • AVL트리에서의 삽입은 두 단계로 수행
# • [1 단계] 이진탐색트리의 삽입과 동일하게 새로운 노드 삽입
# • [2 단계] 새로 삽입한 노드로부터 루트로 거슬러 올라가며 각 노드
# 의 서브트리 높이 차이를 갱신
#
#  AVL 트리의 삭제 연산
# • AVL트리에서의 삭제는 두 단계로 진행
# • [1단계] 이진탐색트리에서와 동일한 삭제 연산 수행
# • [2단계] 삭제된 노드로부터 루트노드 방향으로 거슬러 올라가며 불
# 균형이 발생한 경우 적절한 회전 연산 수행
# • [핵심 아이디어] 삭제 후 불균형이 발생하면 반대쪽에 삽입이 이루
# 어져 불균형이 발생한 것으로 취급하자
#
# 수행시간
# • AVL 트리에서의 탐색, 삽입, 삭제 연산은 공통적으로 루트부터 탐
# 색을 시작하여 최악의 경우에 이파리까지 내려가고, 삽입이나 삭제
# 연산은 다시 루트까지 거슬러 올라가야
# • 트리를 한 층 내려갈 때는 재귀호출하며, 한 층을 올라갈 때 불균형
# 이 발생하면 적절한 회전 연산을 수행하는데, 이들 각각은 O(1) 시
# 간 밖에 걸리지 않음
# • 탐색, 삽입, 삭제 연산의 수행시간은 각각 AVL의 높이에 비례하므
# 로 각 연산의 수행시간은 O(logN)
# • 다양한 실험결과에 따르면, AVL 트리는 거의 정렬된 데이터를 삽입
# 한 후에 랜덤 순서로 데이터를 탐색하는 경우 가장 좋은 성능을 보
# 임
# • 이진탐색트리는 랜덤 순서의 데이터를 삽입한 후에 랜덤 순서로 데
# 이터를 탐색하는 경우 가장 좋은 성능을 보임a
#
# 2-3트리
# • 2-3 트리는 내부 노드의 차수가 2 또는 3인 균형 탐색트리
# • 차수가 2인 노드 = 2-노드, 차수가 3인 노드 = 3-노드
# • 2-노드: 한 개의 키를 가지며, 3-노드는 두 개의 키를 가짐
# • 2-3 트리는 루트로부터 각 이파리까지 경로의 길이가 같고, 모든 이
# 파리들이 동일한 층에 있는 완전한 균형트리
# • 2-3 트리가 2-노드들만으로 구성되면 포화이진트리와 동일한 형태
# 를 가짐
# • [핵심 아이디어] 2-3트리는 이파리노드들이 동일한 층에 있어야 하
# 므로 트리가 위로 자라나거나 낮아진다
#
# 2-3트리
# • 2-3 트리에서도 이진탐색트리에서의 중위순회와 유사한 방법으로 중위순
# 회 수행
# • 2-노드는 이진트리의 중위순회 방문과 동일
# • k1과 k2를 가진 3-노드에서는 먼저 노드의 왼쪽 서브트리에 있는 모든 노
# 드들을 방문한 후에 k1을 방문하고, 이후에 중간 서브트리에 있는 모든 노
# 드들을 방문
# • 다음으로 k2를 방문하고 마지막으로 오른쪽 서브트리에 있는 모든 노드들
# 을 방문한다.
# • 따라서 2-3트리에서 중위순회를 수행하면 키들이 정렬된 결과를 얻음
#
# 2-3 트리 탐색
# • 루트에서 시작하여 방문한 노드의 키들과 탐색하고자 하는 키를 비
# 교하며 다음 레벨의 노드를 탐색
#
# B-Tree
# • [핵심아이디어] 노드에 수백에서 수천 개의 키를 저장하여 트리의
# 높이를 낮추자.
# • 다수의 키를 가진 노드로 구성되어 다방향 탐색(Multiway
# Search)이 가능한 균형 트리
# • 2-3 트리는 B-트리의 일종으로 노드에 키가 2 개까지 있을 수 있
# 는 트리
# • B-트리는 대용량의 데이터를 위해 고안되어 주로 데이터베이스에
# 사용
# 차수가 M인 B-트리는
# • 모든 이파리들은 동일한 깊이를 갖는다.
# • 각 내부 노드의 자식 수는 éM/2ù 이상 M 이하이다.
# • 루트의 자식 수는 2 이상이다.
#
# B-Tree 탐색연산
# • B-트리에서의 탐색은 루트로부터 시작
# • •방문한 각 노드에서는 탐색하고자 하는 키와 노드의 키들을 비교하
# 여, 적절한 서브트리를 탐색
# • 단, B-트리의 노드는 일반적으로 수백 개가 넘는 키를 가지므로 각
# 노드에서는 이진탐색을 수행
# 삭제연산
# • B-트리에서의 삭제는 항상 이파리에서 이루어진다.
# • 만약 삭제할 키가 속한 노드가 이파리가 아니면, 이진탐색트리의 삭제와 유사
# 하게 중위 선행자나 중위 후속자를 삭제할 키와 교환한 후에 이파리에서 삭제
# 를 수행
# • 삭제는 이동(Transfer) 연산과 통합(Fusion) 연산을 사용
# • 이동 연산: 이파리노드에서 키가 삭제된 후에 키의 수가 보다 작
# 으면, 자식 수가 보다 작게 되어 B-트리 조건을 위반.
# • 이 때 노드의 좌우의 형제들 중에서 도움을 줄 수 있는 노드로부터 1 개의
# 키를 부모를 통해 이동
# 삭제연산
# • 통합 연산: 키가 삭제된 후 underflow가 발생한 노드 x에 대해 이
# 동 연산이 불가능한 경우, 노드 x와 그의 형제를 1 개의 노드로 통
# 합하고, 노드 x와 그의 형제의 분기점 역할을 하던 부모의 키를 통
# 합된 노드로 끌어내리는 연산
#
# B-Tree 확장
# • B*-트리는 B-트리로서 루트를 제외한 다른 노드의 자식 수가
# 2/3M∼M이어야 한다.
# • 즉, 각 노드에 적어도 2/3 이상이 키들로 채워져 있어야
# • B-트리에 비해 B*-트리는 공간을 효율적으로 활용
#
# B+ Tree
# • B+-트리는 실세계에서 가장 널리 활용되는 B-트리
# • B+-트리는 키들만으로 가지고 B-트리를 구성,
# 이파리노드에 키와 관련(실제) 정보를 저장
# • 키들로 구성된 B-트리는 탐색, 삽입, 삭제 연산을 위해 관련된
# 이파리노드를 빠르게 찾을 수 있도록 안내해주는 역할만을 수행
# • B+-트리는 전체 레코드를 순차적으로 접근할 수 있도록 이파리들은
# 연결리스트로 구현