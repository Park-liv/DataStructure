# 단순연결리스트
# • 단순연결리스트(Singly Linked List)는 동적 메모리 할당을 이용
# 해 리스트를 구현하는 가장 간단한 형태의 자료구조
# • 동적 메모리 할당을 받아 노드(node)를 저장하고, 노드는 레퍼런스
# 를 이용하여 다음 노드를 가리키도록 만들어 노드들을 한 줄로 연결시킴
# • 연결리스트에서는 삽입이나 삭제 시 항목들의 이동이 필요 없음
# • 연결리스트에서는 항목을 탐색하려면 항상 첫 노드부터 원하는 노
# 드를 찾을 때까지 차례로 방문하는 순차탐색(Sequential Search)
# 해야 함
# • search()는 탐색을 위해 연결리스트의 노드들을 첫 노드부터 순차
# 적으로 방문해야 하므로 O(N) 시간 소요
# • 삽입이나 삭제 연산은 각각 O(1) 개의 레퍼런스만을 갱신하므로
# O(1) 시간 소요
# • 단, insert_after()나 delete_after()의 경우에 특정 노드 p의 레
# 퍼런스가 주어지지 않으면 head로부터 p를 찾기 위해 search()
# 를 수행해야 하므로 O(N) 시간 소요
#
# 이중연결리스트
# • 이중연결리스트(Doubly Linked List)는 각 노드가 두 개의 레퍼런스
# 를 가지고 각각 이전 노드와 다음 노드를 가리키는 연결리스트
# • 단순연결리스트는 삽입이나 삭제할 때 반드시 이전 노드를 가리키는 레
# 퍼런스를 추가로 알아내야 하고, 역방향으로 노드들을 탐색할 수 없음
# • 이중연결리스트는 단순연결리스트의 이러한 단점을 보완하나, 각 노드
# 마다 추가로 한 개의 레퍼런스를 추가로 저장해야 한다는 단점을 가짐
# 수행복잡도분석
# • search()는 탐색을 위해 연결리스트의 노드들을 첫 노드부터 순차
# 적으로 방문해야 하므로 O(N) 시간 소요
# • 삽입이나 삭제 연산은 각각 O(1) 개의 레퍼런스만을 갱신하므로
# O(1) 시간 소요
# • 단, insert_after()나 delete_after()의 경우에 특정 노드 p의 레
# 퍼런스가 주어지지 않으면 head로부터 p를 찾기 위해 search()
# 를 수행해야 하므로 O(N) 시간 소요
#
# 원형연결리스트
# • 원형연결리스트(Circular Linked List)는 마지막 노드가 첫 노드
# 와 연결된 단순연결리스트
# • 원형연결리스트에서는 마지막 노드의 레퍼런스가 저장된 last가 단
# 순연결리스트의 head와 같은 역할
# • 마지막 노드와 첫 노드를 O(1) 시간에 방문할 수 있는 장점
# • 리스트가 empty가 아니면 어떤 노드도 None 레퍼런스를 가지고
# 있지 않으므로 프로그램에서 None 조건을 검사하지 않아도 되는
# 장점
# • 원형연결리스트에서는 반대 방향으로 노드들을 방문하기 쉽지 않으
# 며, 무한 루프가 발생할 수 있음에 유의할 필요
# • 여러 사람이 차례로 돌아가며 하는 게임을 구현하는데 적합한 자료
# 구조
# • 많은 사용자들이 동시에 사용하는 컴퓨터에서 CPU 시간을 분할하
# 여 작업들에 할당하는 운영체제에 사용
# • 이항힙(Binomial Heap)이나 피보나치힙(Fibonacci Heap)과 같
# 은 우선순위큐를 구현하는 데에도 원형연결리스트가 부분적으로 사용
# 수행복잡도분석
# • 원형연결리스트에서 삽입이나 삭제 연산 각각 상수 개의 레퍼런스
# 를 갱신하므로 O(1) 시간에 수행
# • 탐색 연산: last로부터 노드들을 순차적으로 탐색해야 하므로 O(N) 소요
